local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game.Players 
local localPlayer = Players.LocalPlayer
local standbymode = false
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Evarge Control Panel",
    LoadingTitle = "Evarge Studios",
    LoadingSubtitle = "by Evarge",
    Theme = "Default"
})
function findPlayerByPartialName(partialName)
    for _, player in ipairs(game.Players:GetPlayers()) do
        if string.find(player.Name:lower(), partialName:lower(), 1, true) or 
        string.find(player.DisplayName:lower(), partialName:lower(), 1, true) then
            return player  -- Return the first matching player
        end
    end
    return nil  -- No match found
end

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local rootPart = character:FindFirstChild("HumanoidRootPart")

player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = newCharacter:WaitForChild("Humanoid")
    rootPart = newCharacter:WaitForChild("HumanoidRootPart")
end)

local Allies = {}
local function isAllied(plr)
    return Allies[plr.UserId] == true
end

local airstrikeActive = false
local targetUser = nil
local targetHumanoidRootPart = nil

local following = false
local followTarget = nil
local spinning = false
local spinSpeed = 0
local driving = false
local driveSpeed = 0
local banging = false
local bangSpeed = 0
local bangTarget = nil
local bangTime = 0
local orbiting = false
local orbitTarget = nil
local orbitHeight = 5
local orbitDistance = 5
local orbitSpeed = 5
local orbitAngle = 0
local autoJump = false
local touring = false
local narutoBalling = false
local maxNarutoHeight = 10
local currentHeight = 0
local spinSpeed = 1000000 -- High-speed spinning
local floatSpeed = 2 -- Speed of floating upwards
local originalCFrame = nil
local floating = false
local floatBaseY = nil
local staring = false
local stareTarget = nil
local annoying = false
local annoyTarget = nil
local helicopter = false
local helicopterSpinSpeed = 360
local helicopterTime = 0
local guard = false
local guardSide = nil
local guardTarget = nil
local controllerPlayer = nil
local notified = false
local headstanding = false
local headstandTarget = nil
local inArmy = false
local armyIndex = nil
local armyTarget = nil
local copyChat = false
local copyChatTarget = nil
local walkingToTarget = false


-- ;NPC VARS
local npcSettings = {
    messageWaitTime = {6, 10},  -- Time in seconds between messages
    moveWaitTime = {1, 2},      -- Time in seconds between movements
    moveDistance = {50, 100}    -- Max random distance for movement
}
local npcMode = false
local npcThread
local npcPhrases = {
    "Hows the weather today? ‚òÄÔ∏è",
    "I think I lost something... ü§î",
    "What a great day! üòÉ",
    "Hello traveler! üëã",
    "I heard something strange... üëÄ",
    "Did you hear that? üò®",
    "Hmm... something feels off. üòµ",
    "Do you need help? ü§ñ",
    "Just another day... ‚è≥",
    "Be careful out there! ‚ö†Ô∏è",
    "Have you seen my keys? üîë",
    "I wonder what‚Äôs for dinner‚Ä¶ üç¥",
    "I feel like something's watching me... üëÄ",
    "Are we there yet? ‚è±Ô∏è",
    "I can‚Äôt remember where I was going... üòï",
    "Oh, I love this song! üé∂",
    "Maybe I should go for a walk. üö∂",
    "Did you hear the latest news? üì∞",
    "I need a break. üòå",
    "I think I left the oven on... üç≥",
    "What‚Äôs that sound? üéß",
    "I'm so tired... üò¥",
    "Wait, did I leave the door open? üö™",
    "I should probably do some work... üìö",
    "I'm not sure if I should go this way... ü§î",
    "I think I saw a ghost... üëª",
    "Sometimes I wonder what‚Äôs beyond the stars... üåü",
    "I feel like exploring today! üåç",
    "I should probably call my friend... üìû",
    "The sky is so beautiful today! üåÖ",
    "Hmm, this place is kind of strange... üòï",
    "I need to clean up... üßπ",

}


-- A small list of dad jokes for the ;dadjoke command
local dadJokes = {
    "Why did the scarecrow get promoted? Because he was outstanding in his field.",
    "I‚Äôm reading a book about anti-gravity. It‚Äôs impossible to put down!",
    "What do you call cheese that isn‚Äôt yours? Nacho cheese!",
    "Why did the math book look so sad? Because it had so many problems.",
    "I‚Äôm on a seafood diet. I see food, and I eat it!",
    "Why don‚Äôt skeletons fight each other? They don‚Äôt have the guts.",
    "I told my wife she was drawing her eyebrows too high. She looked surprised.",
    "What‚Äôs orange and sounds like a parrot? A carrot!",
    "Why don‚Äôt eggs tell jokes? Because they‚Äôd crack each other up.",
    "I used to play piano by ear, but now I use my hands.",
    "I can‚Äôt believe I got fired from the calendar factory. All I did was take a day off.",
    "How do you organize a space party? You planet.",
    "I told my computer I needed a break, and now it won‚Äôt stop sending me Kit-Kats.",
    "I‚Äôm terrified of elevators, so I‚Äôm going to start taking steps to avoid them.",
    "I‚Äôm reading a book on the history of glue. I just can‚Äôt seem to put it down.",
    "I used to be a baker, but I couldn't make enough dough.",
    "What‚Äôs a skeleton‚Äôs least favorite room? The living room.",
    "Why did the bicycle fall over? Because it was two-tired.",
    "What do you get when you cross a snowman with a vampire? Frostbite.",
    "I‚Äôm friends with all electricians. We have good current connections.",
    "Why don't seagulls fly over the bay? Because then they'd be bagels.",
    "Why did the tomato turn red? Because it saw the salad dressing!",
    "I would tell you a joke about a roof, but it might go over your head.",
    "What‚Äôs the best way to watch a fly fishing tournament? Live stream.",
    "What‚Äôs the most valuable part of a joke? The punchline!",
    "I‚Äôve started investing in stocks: beef, chicken, and vegetable. One day I hope to be a bouillonaire.",
    "What do you get if you cross a dog and a computer? A lot of bites!",
    "Why don‚Äôt oysters share their pearls? Because they‚Äôre shellfish."
}


local maintab = Window:CreateTab("Main")
local creditstab = Window:CreateTab("Credits")
local functionstab = Window:CreateTab("Functions")
local controlsection = maintab:CreateSection("Controller")

local allfuncs = [[
;jump
;bring
;align <distance>
;follow [user]
;unfollow
;spin [speed]
;unspin
;orbit [target] [height] [distance] [speed]
;stick <user> [speed]
;unstick / ;unorbit
;tour
;untour
;drive [speed]
;dance
;undrive
;bang <user> [speed]
;unbang
;float
;unfloat
;sit
;unsit
;locate <user>
;tp/goto/teleport <user>
;stareat <user>
;unstareat
;annoy <user>
;unannoy
;helicopter [speed]
;unhelicopter
;guard <user> left/right
;unguard
;backflip
;frontflip
;headstand <user>
;unheadstand
;army [user?]
;unarmy
;copychat <user>
;uncopychat
;playdead
;unplaydead
;ally <user>
;unally <user>
;reset / ;respawn
;ajump / ;autojump
;unajump / ;unautojump
;scare <user> / ;spook <user>
;npc
;unnpc
;dadjoke
;ancientfigher
;narutoball
;gtest
]]

local allcredits = [[
Owner - Evarge
Scripter - Roro
Key - Henrick
]]

RunService.RenderStepped:Connect(function(dt)
    if narutoBalling and rootPart then
        -- Spin extremely fast
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed * dt), 0)

        -- Float up smoothly until reaching max height
        if currentHeight < maxNarutoHeight then
            currentHeight = math.min(currentHeight + (floatSpeed * dt), maxNarutoHeight)
            -- Update the CFrame to float upwards by modifying the Y position
            rootPart.CFrame = CFrame.new(rootPart.Position.X, floatBaseY + currentHeight, rootPart.Position.Z)
        end
    end
end)

local Paragraph = functionstab:CreateParagraph({Title = "Functions: ", Content = allfuncs})
local Paragraph2 = creditstab:CreateParagraph({Title = "Credits: ", Content = allcredits})

local Input = maintab:CreateInput({
    Name = "Controller: ",
    CurrentValue = "",
    PlaceholderText = "Name or display name",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        if not standbymode then
            local inpt = Text:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(inpt) or p.DisplayName:lower():find(inpt) then
                    controllerPlayer = p
                    Rayfield:Notify({
                        Title = "Set successfully",
                        Content = "Successfully set controller",
                        Duration = 4.5,
                        Image = "rewind"
                    })
                    return
                end
            end
            Rayfield:Notify({
                Title = "Couldnt set",
                Content = "Couldnt set controller",
                Duration = 4.5,
                Image = "rewind"
            })
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Controller can not be used while stand is on",
                Duration = 4.5,
                Image = "rewind"
            })
            notified = true
        end
    end
})
local function getTargetUser(targetName)
    -- Normalize the target name by converting it to lowercase for case-insensitive comparison
    targetName = targetName:lower()

    -- Iterate through all players in the game
    for _, player in pairs(game.Players:GetPlayers()) do
        -- Check if the target's username or display name starts with the input target name
        if player.Name:lower():sub(1, #targetName) == targetName or player.DisplayName:lower():sub(1, #targetName) == targetName then
            return player  -- Return the matched player
        end
    end

    return nil  -- If no match is found, return nil
end


RunService.RenderStepped:Connect(function(dt)
    if airstrikeActive and rootPart and rootPart.Parent then
        -- If we are boosting upwards
        if currentHeight < 100 then
            currentHeight = currentHeight + (5 * dt)  -- Speed of upward movement
            rootPart.CFrame = CFrame.new(rootPart.Position.X, floatBaseY + currentHeight, rootPart.Position.Z)
        elseif currentHeight >= 100 and targetHumanoidRootPart then
            -- Face downwards
            local directionToTarget = (targetHumanoidRootPart.Position - rootPart.Position).unit
            rootPart.CFrame = CFrame.lookAt(rootPart.Position, targetHumanoidRootPart.Position) -- Face downwards

            -- Move downwards to the target
            local downwardSpeed = 50  -- Speed for falling
            local direction = Vector3.new(0, -1, 0)  -- Moving down
            rootPart.CFrame = rootPart.CFrame + direction * downwardSpeed * dt

            -- Check if we have reached the target
            if (rootPart.Position - targetHumanoidRootPart.Position).Magnitude < 5 then
                -- Reset position and stop the airstrike
                airstrikeActive = false
                currentHeight = 0  -- Reset height
                Rayfield:Notify({
                    Title = "Airstrike Complete!",
                    Content = "Target hit! Airstrike finished.",
                    Duration = 3
                })
            end
        end
    end
end)
local Toggle = maintab:CreateToggle({
    Name = "Stand",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        standbymode = Value
        if standbymode then
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local targetPlayer = nil
            local originalPosition = rootPart.Position
            local isFollowing = false
            local followSide = "right"
            local floatingHeight, followDistance = 3, 3
            local floatAmplitude, floatSpeed = 1, 2
            local timeElapsed = 0
            local standbymode2 = false
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = player:WaitForChild("PlayerGui")
            screenGui.ResetOnSpawn = false
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(0, 300, 0, 280)
            frame.Position = UDim2.new(0.5, -150, 0.25, 0)
            frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            frame.BackgroundTransparency = 0.2
            frame.BorderSizePixel = 0
            frame.Parent = screenGui
            local frameCorner = Instance.new("UICorner")
            frameCorner.CornerRadius = UDim.new(0, 12)
            frameCorner.Parent = frame
            local dragging, dragInput, dragStart, startPos
            local function dragFrame(input)
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
            frame.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    dragFrame(input)
                end
            end)
            UserInputService.InputChanged:Connect(function(input)
                if dragging and input == dragInput then
                    local delta = input.Position - dragStart
                    frame.Position = UDim2.new(
                        startPos.X.Scale,
                        startPos.X.Offset + delta.X,
                        startPos.Y.Scale,
                        startPos.Y.Offset + delta.Y
                    )
                end
            end)
            frame.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement then
                    dragInput = input
                end
            end)
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 40)
            title.BackgroundTransparency = 1
            title.Text = "Evarge Stand"
            title.Font = Enum.Font.GothamBold
            title.TextSize = 20
            title.TextColor3 = Color3.new(1, 1, 1)
            title.Parent = frame
            local textBox = Instance.new("TextBox")
            textBox.Size = UDim2.new(0.85, 0, 0, 35)
            textBox.Position = UDim2.new(0.075, 0, 0.20, 0)
            textBox.PlaceholderText = "Enter Username/Display Name"
            textBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            textBox.TextColor3 = Color3.new(1, 1, 1)
            textBox.Font = Enum.Font.Gotham
            textBox.TextSize = 14
            textBox.Parent = frame
            Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 8)
            local function createButton(text, yPos, color)
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(0.85, 0, 0, 35)
                btn.Position = UDim2.new(0.075, 0, yPos, 0)
                btn.Text = text
                btn.BackgroundColor3 = color or Color3.fromRGB(50, 50, 50)
                btn.TextColor3 = Color3.new(1, 1, 1)
                btn.Font = Enum.Font.GothamBold
                btn.TextSize = 16
                btn.Parent = frame
                Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
                return btn
            end
            local leftBtn = createButton("Follow on Left", 0.40)
            local rightBtn = createButton("Follow on Right", 0.58)
            local stopBtn = createButton("Stop Stand", 0.76, Color3.fromRGB(140, 40, 40))
            local function findTarget()
                local input = textBox.Text:lower()
                targetPlayer = nil
                if #input < 3 then return end
                for _, plr in pairs(Players:GetPlayers()) do
                    local name, display = plr.Name:lower(), plr.DisplayName:lower()
                    if name:find(input) or display:find(input) then
                        targetPlayer = plr
                        break
                    end
                end
            end
            leftBtn.MouseButton1Click:Connect(function()
                findTarget()
                if targetPlayer then
                    isFollowing = true
                    standbymode2 = true
                    followSide = "left"
                end
            end)
            rightBtn.MouseButton1Click:Connect(function()
                findTarget()
                if targetPlayer then
                    isFollowing = true
                    standbymode2 = true
                    followSide = "right"
                end
            end)
            stopBtn.MouseButton1Click:Connect(function()
                isFollowing = false
                standbymode2 = false
                rootPart.CFrame = CFrame.new(originalPosition)
            end)
            RunService.RenderStepped:Connect(function(dt)
                if standbymode2 then
                    timeElapsed = timeElapsed + dt
                    local floatOffset = math.sin(timeElapsed * floatSpeed) * floatAmplitude
                    if character and rootPart then
                        local currentCFrame = rootPart.CFrame
                        local targetPosition = currentCFrame.Position + Vector3.new(0, floatOffset, 0)
                        rootPart.CFrame = CFrame.new(targetPosition)
                    end
                    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local targetRoot = targetPlayer.Character.HumanoidRootPart
                        local targetPosition = targetRoot.Position
                        local targetRightVector = targetRoot.CFrame.RightVector
                        local targetOrientation = targetRoot.CFrame.LookVector
                        local offsetDirection = (followSide == "right") and 1.5 or -1.5
                        local followPosition = targetPosition
                            - (targetOrientation * followDistance)
                            + (targetRightVector * offsetDirection)
                            + Vector3.new(0, floatingHeight + floatOffset, 0)
                        rootPart.CFrame = CFrame.new(followPosition, followPosition + targetOrientation)
                    end
                end
            end)
        else
            local oldGui = player.PlayerGui:FindFirstChild("ScreenGui")
            if oldGui then
                oldGui:Destroy()
            end
        end
    end
})

local function replicateMessage(msg)
    local chatEvent = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
    chatEvent:FireServer(msg, "All")
end

local function onChatMessage(playerChat, message)
    if copyChat and playerChat == copyChatTarget then
        TextChatService.TextChannels.RBXGeneral:SendAsync(message)
    end
    if playerChat == controllerPlayer then
        local args = message:split(" ")
        if args[1] == ";jump" then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        elseif args[1] == ";bring" then
            if controllerPlayer and controllerPlayer.Character then
                rootPart.CFrame = controllerPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
            end
        elseif args[1] == ";align" then
            local dist = tonumber(args[2]) or 3
            if controllerPlayer and controllerPlayer.Character then
                local cRoot = controllerPlayer.Character:FindFirstChild("HumanoidRootPart")
                if cRoot then
                    rootPart.CFrame = cRoot.CFrame * CFrame.new(-dist, 0, 0)
                end
            end
        elseif args[1]:lower() == ";narutoball" then
            if not spinning then
                spinning = true
                spinSpeed = 10000
                Rayfield:Notify({
                    Title = "Naruto Ball Activated!",
                    Content = "You have startd spinning.",
                    Duration = 3
                })
            end
        
        elseif args[1]:lower() == ";unnarutoball" then
            spinning = false
            Rayfield:Notify({
                Title = "Naruto Ball Deactivated!",
                Content = "You have stopped spinning.",
                Duration = 3
            })

        elseif args[1]:lower() == ";gtest" and args[2] then
            local targetUser = args[2]:lower()
            local targetPlayer = nil
        
            -- Check if the given name matches any player (Username or DisplayName)
            for _, player in ipairs(game.Players:GetPlayers()) do
                if string.find(player.Name:lower(), targetUser) or string.find(player.DisplayName:lower(), targetUser) then
                    targetPlayer = player
                    break
                end
            end
        
            if targetPlayer then
                -- Generate a random percentage from 0 to 100
                local randomPercentage = math.random(0, 100)
        
                -- Send the message to the general chat
                local message = targetPlayer.DisplayName .. " is " .. randomPercentage .. "üè≥Ô∏è‚Äçüåà"
                game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(message)
            else
                -- Notify if the player was not found
                Rayfield:Notify({
                    Title = "Error!",
                    Content = "Player not found!",
                    Duration = 3
                })
            end
        
        
        
            
        elseif args[1] == ";follow" then
            if args[2] then
                local targetName = args[2]:lower()
                for _, p in pairs(Players:GetPlayers()) do
                    if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                        if isAllied(p) then
                            Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                            return
                        end
                        followTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                        break
                    end
                end
            else
                followTarget = controllerPlayer and controllerPlayer.Character and controllerPlayer.Character:FindFirstChild("HumanoidRootPart")
            end
            if followTarget then
                following = true
            end
        elseif args[1] == ";unfollow" then
            following = false
            followTarget = nil
        elseif args[1] == ";spin" then
            local speed = tonumber(args[2]) or 30
            spinning = true
            spinSpeed = speed
        elseif args[1] == ";unspin" then
            spinning = false
            spinSpeed = 0
        elseif args[1] == ";orbit" and args[2] then
            local targetName = args[2]:lower()
            local height = tonumber(args[3]) or 5
            local distance = tonumber(args[4]) or 5
            local speed = tonumber(args[5]) or 5
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    orbiting = true
                    orbitTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    orbitHeight = height
                    orbitDistance = distance
                    orbitSpeed = speed * 5
                    orbitAngle = 0
                    break
                end
            end
        elseif args[1] == ";stick" and args[2] then
            local targetName = args[2]:lower()
            local speed = tonumber(args[3]) or 20
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    orbiting = true
                    orbitTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    orbitHeight = 1
                    orbitDistance = 0
                    orbitSpeed = speed
                    orbitAngle = 0
                    break
                end
            end
        elseif args[1] == ";unstick" or args[1] == ";unorbit" then
            orbiting = false
            orbitTarget = nil
        elseif args[1] == ";tour" then
            touring = true
            originalCFrame = rootPart.CFrame
            spawn(function()
                while touring do
                    for _, p in pairs(Players:GetPlayers()) do
                        if not touring then break end
                        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                            rootPart.CFrame = p.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                            wait(0.01)
                        end
                    end
                end
            end)
        elseif args[1] == ";untour" then
            touring = false
            if controllerPlayer and controllerPlayer.Character and controllerPlayer.Character:FindFirstChild("HumanoidRootPart") then
                rootPart.CFrame = controllerPlayer.Character.HumanoidRootPart.CFrame
            else
                rootPart.CFrame = originalCFrame or rootPart.CFrame
            end
        elseif args[1] == ";drive" then
            local speed = tonumber(args[2]) or 25
            driving = true
            driveSpeed = speed
        elseif args[1] == ";undrive" then
            driving = false
            driveSpeed = 0
        elseif args[1] == ";bang" and args[2] then
            local targetName = args[2]:lower()
            local speed = tonumber(args[3]) or 5
            if speed then
                for _, p in pairs(Players:GetPlayers()) do
                    if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                        if isAllied(p) then
                            Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                            return
                        end
                        banging = true
                        bangSpeed = speed
                        bangTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                        bangTime = 0
                        break
                    end
                end
            end
        elseif args[1] == ";unbang" then
            banging = false
            bangTarget = nil
        elseif args[1]:lower() == ";float" then
            floating = true
            floatBaseY = rootPart.Position.Y
            floatHeight = tonumber(args[2]) or 5 -- Default to 5 if no height is given
        
            Rayfield:Notify({
                Title = "Floating",
                Content = "Now floating at height: " .. floatHeight,
                Duration = 3
            })
        elseif args[1]:lower() == ";unfloat" then
            floating = false
        
            Rayfield:Notify({
                Title = "Floating Disabled",
                Content = "Stopped floating.",
                Duration = 3
            })
        elseif args[1] == ";sit" then
            if humanoid then
                humanoid.Sit = true
            end
        elseif args[1] == ";rj" or args[1] == ";rejoin" then
            local placeId = game.PlaceId
            game:GetService("TeleportService"):Teleport(placeId, player)
        elseif args[1] == ";unsit" then
            if humanoid then
                humanoid.Sit = false
            end
        elseif args[1] == ";locate" and args[2] then
            local targetName = table.concat(args, " ", 2):lower()
            local foundPlayer
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    foundPlayer = p
                    break
                end
            end
            if foundPlayer then
                local gui = Instance.new("ScreenGui")
                local frame = Instance.new("Frame")
                local textLabel = Instance.new("TextLabel")
                gui.Name = "DistanceDisplay"
                gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                gui.Parent = game.CoreGui
                frame.Size = UDim2.new(0, 200, 0, 40)
                frame.Position = UDim2.new(1, -210, 1, -50)
                frame.BackgroundColor3 = Color3.new(0, 0, 0)
                frame.BackgroundTransparency = 0.5
                frame.Parent = gui
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.TextColor3 = Color3.new(1, 1, 1)
                textLabel.Font = Enum.Font.GothamBold
                textLabel.TextSize = 14
                textLabel.Text = "Calculating..."
                textLabel.Parent = frame
                local startTime = os.time()
                local lastChat = 0
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if not controllerPlayer or not foundPlayer or not foundPlayer.Character then
                        connection:Disconnect()
                        gui:Destroy()
                        return
                    end
                    local cRoot = controllerPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local tRoot = foundPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if cRoot and tRoot then
                        local dist = math.floor((cRoot.Position - tRoot.Position).Magnitude)
                        textLabel.Text = "Studs: "..tostring(dist)
                        if os.time() - lastChat >= 1 then
                            pcall(function()
                                TextChatService.TextChannels.RBXGeneral:SendAsync("Studs: "..dist)
                            end)
                            lastChat = os.time()
                        end
                    end
                    if os.time() - startTime >= 3 then
                        connection:Disconnect()
                        gui:Destroy()
                    end
                end)
            else
                Rayfield:Notify({
                    Title = "Locate Failed",
                    Content = "Player not found",
                    Duration = 3
                })
            end
        elseif (args[1] == ";tp" or args[1] == ";goto" or args[1] == ";teleport") and args[2] then
            local targetName = table.concat(args, " ", 2):lower()
            local foundPlayer
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    foundPlayer = p
                    break
                end
            end
            if foundPlayer and foundPlayer.Character and foundPlayer.Character:FindFirstChild("HumanoidRootPart") then
                rootPart.CFrame = foundPlayer.Character.HumanoidRootPart.CFrame
                Rayfield:Notify({
                    Title = "Teleported",
                    Content = "Teleported to "..foundPlayer.DisplayName,
                    Duration = 2
                })
            else
                Rayfield:Notify({
                    Title = "Teleport Failed",
                    Content = "Player not found",
                    Duration = 3
                })
            end
        elseif args[1] == ";stareat" and args[2] then
            local targetName = args[2]:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    staring = true
                    stareTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    break
                end
            end
        elseif args[1] == ";unstareat" then
            staring = false
            stareTarget = nil
        elseif args[1] == ";annoy" and args[2] then
            local targetName = args[2]:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping command",Duration=3})
                        return
                    end
                    annoying = true
                    annoyTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    break
                end
            end
            -- Function to find a player with partial name matching
            --[[
        elseif args[1]:lower() == ";airstrike" and args[2] then
            local targetUser = args[2]:lower()
            local targetPlayer = nil
        
            -- Find target by partial username or display name
            for _, player in ipairs(game.Players:GetPlayers()) do
                if string.find(player.Name:lower(), targetUser) or string.find(player.DisplayName:lower(), targetUser) then
                    targetPlayer = player
                    break
                end
            end
            local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
            if targetPlayer and targetPlayer.Character then
                local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local playerRoot = hrp -- Use your HumanoidRootPart
                    local textService = game:GetService("TextChatService")
                    local tweenService = game:GetService("TweenService")
        
                    -- Notify
                    Rayfield:Notify({
                        Title = "Airstrike Initiated!",
                        Content = "Locking onto " .. targetPlayer.Name .. "!",
                        Duration = 3
                    })
        
                    -- Fix for character getting stuck
                    localPlayer.Character.PrimaryPart.Anchored = true  
        
                    -- Send hacker messages while ascending
                    task.spawn(function()
                        textService:DisplaySystemMessageAsync("[SYSTEM] Relocating " .. targetPlayer.Name .. " ...", Color3.fromRGB(255, 0, 0))
                        wait(1)
                        textService:DisplaySystemMessageAsync("[SYSTEM] Target locked. Preparing for impact.", Color3.fromRGB(255, 255, 0))
                        wait(1.5)
                        textService:DisplaySystemMessageAsync("[SYSTEM] Deploying final strike.", Color3.fromRGB(0, 255, 0))
                    end)
        
                    -- **Use Tween Teleport to Move Upwards (SLOWLY)**
                    local currentPosition = playerRoot.Position
                    local targetPositionUp = currentPosition + Vector3.new(0, 100, 0)
                    
                    -- Calculate time based on distance
                    local distanceUp = (targetPositionUp - currentPosition).Magnitude
                    local tweenTimeUp = distanceUp / (tweenspeed + 1)
                    tweenTimeUp = math.max(tweenTimeUp, 1.5) -- Ensure at least 1.5s
        
                    local tweenInfoUp = TweenInfo.new(tweenTimeUp, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                    local goalUp = {CFrame = CFrame.new(targetPositionUp)}
                    local tweenUp = tweenService:Create(playerRoot, tweenInfoUp, goalUp)
        
                    tweenUp:Play()
                    tweenUp.Completed:Connect(function()
                        -- **Use Tween Teleport to Move Towards Target (FAST)**
                        local targetPositionDown = targetRoot.Position
                        
                        -- Calculate time based on distance
                        local distanceDown = (targetPositionDown - targetPositionUp).Magnitude
                        local tweenTimeDown = distanceDown / (tweenspeed + 5) -- Faster downward speed
                        tweenTimeDown = math.max(tweenTimeDown, 0.75) -- Ensure at least 0.75s
                        
                        local tweenInfoDown = TweenInfo.new(tweenTimeDown, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
                        local goalDown = {CFrame = CFrame.new(targetPositionDown)}
                        local tweenDown = tweenService:Create(playerRoot, tweenInfoDown, goalDown)
        
                        tweenDown:Play()
                        tweenDown.Completed:Connect(function()
                            -- Reset movement
                            localPlayer.Character.PrimaryPart.Anchored = false  
        
                            -- Explosion message
                            textService:DisplaySystemMessageAsync("[SYSTEM] BOOM üí• Target eliminated!", Color3.fromRGB(255, 0, 0))
        
                            -- Notify impact
                            Rayfield:Notify({
                                Title = "üí• BOOM!",
                                Content = "Target " .. targetPlayer.Name .. " has been destroyed!",
                                Duration = 3
                            })
                            
                            -- Simulate explosion (Optional: Kill Player)
                            localPlayer.Character:BreakJoints()
                        end)
                    end)
                end
            else
                Rayfield:Notify({
                    Title = "Error!",
                    Content = "Target not found!",
                    Duration = 3
                })
            end
        
        elseif args[1]:lower() == ";unairstrike" then
            -- Cancel airstrike logic
            localPlayer.Character.PrimaryPart.Anchored = false  
            Rayfield:Notify({
                Title = "Airstrike Canceled",
                Content = "You stopped the airstrike.",
                Duration = 3
            })--]]


        elseif args[1]:lower() == ";ancientfighter" then
            local character = localPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local hrp = character.HumanoidRootPart
                local TweenService = game:GetService("TweenService")
        
                -- Step 1: Smooth Float Up (Amplitude 15-20)
                local floatUp = TweenService:Create(hrp, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    CFrame = hrp.CFrame + Vector3.new(0, math.random(15, 20), 0)
                })
                floatUp:Play()
                floatUp.Completed:Wait()
        
                -- Step 2: Rotate to Face Forward
                local faceFront = TweenService:Create(hrp, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, 0, 0)
                })
                faceFront:Play()
                faceFront.Completed:Wait()
        
                -- Step 3: Slowly Tilt Upwards (Preparing for Launch)
                local tiltUp = TweenService:Create(hrp, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    CFrame = hrp.CFrame * CFrame.Angles(-math.rad(60), 0, 0) -- Tilts upwards 60 degrees
                })
                tiltUp:Play()
                tiltUp.Completed:Wait()
                TextChatService.TextChannels.RBXGeneral:SendAsync("KABOOM")
                -- Step 4: Epic Launch Off the Map
                Rayfield:Notify({
                    Title = "KABOOM üí•",
                    Content = "You have ascended beyond mortal limits!",
                    Duration = 3
                })
                local finalBoost = TweenService:Create(hrp, TweenInfo.new(3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
                    CFrame = hrp.CFrame + hrp.CFrame.LookVector * 1000 + Vector3.new(0, 500, 0) -- Boosts forward and upwards
                })
                finalBoost:Play()
            end
        
        
        
        
        
        


            
        elseif args[1] == ";unannoy" then
            annoying = false
            annoyTarget = nil
        elseif args[1] == ";helicopter" then
            following = false
            spinning = false
            driving = false
            banging = false
            orbiting = false
            touring = false
            staring = false
            annoying = false
            floating = false
            helicopter = true
            helicopterTime = 0
            helicopterSpinSpeed = tonumber(args[2]) or 360
        elseif args[1] == ";unhelicopter" then
            helicopter = false
            helicopterSpinSpeed = 360
        elseif args[1] == ";guard" and args[2] and args[3] then
            local targetName = args[2]:lower()
            local sideArg = args[3]:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    guard = true
                    guardSide = sideArg
                    guardTarget = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    Rayfield:Notify({
                        Title = "Guard",
                        Content = "Guarding "..p.DisplayName.." on side: "..sideArg,
                        Duration = 3
                    })
                    break
                end
            end
        elseif args[1] == ";unguard" then
            guard = false
            guardSide = nil
            guardTarget = nil
        elseif args[1] == ";backflip" then
            if character and humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                wait(0.2)
                if rootPart then
                    rootPart.CFrame = rootPart.CFrame * CFrame.Angles(math.rad(-180), 0, 0)
                    wait(0.5)
                end
            end
        elseif args[1] == ";frontflip" then
            if character and humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                wait(0.2)
                if rootPart then
                    rootPart.CFrame = rootPart.CFrame * CFrame.Angles(math.rad(180), 0, 0)
                    wait(0.5)
                end
            end
        elseif args[1] == ";headstand" and args[2] then
            local targetName = args[2]:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    if isAllied(p) then
                        Rayfield:Notify({Title="Ally Found",Content="User is allied, skipping headstand",Duration=3})
                        return
                    end
                    headstanding = true
                    headstandTarget = p
                    Rayfield:Notify({
                        Title="Headstand",
                        Content="Standing on "..p.DisplayName.."'s head!",
                        Duration=3
                    })
                    break
                end
            end
        elseif args[1] == ";unheadstand" then
            headstanding = false
            headstandTarget = nil
            Rayfield:Notify({
                Title="Headstand",
                Content="Stopped headstanding",
                Duration=3
            })
        elseif args[1] == ";playdead" then
            if humanoid and rootPart then
                humanoid.PlatformStand = true
                rootPart.CFrame = rootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0)
            end
        elseif args[1] == ";unplaydead" then
            if humanoid then
                humanoid.PlatformStand = false
                humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        elseif args[1] == ";ally" and args[2] then
            local targetName = table.concat(args, " ", 2):lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    Allies[p.UserId] = true
                    Rayfield:Notify({
                        Title = "Allied",
                        Content = p.DisplayName.." is now allied",
                        Duration = 3
                    })
                    return
                end
            end
            Rayfield:Notify({Title="Ally Failed",Content="User not found",Duration=3})
        elseif args[1] == ";unally" and args[2] then
            local targetName = table.concat(args, " ", 2):lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    Allies[p.UserId] = nil
                    Rayfield:Notify({
                        Title = "Unallied",
                        Content = p.DisplayName.." is no longer allied",
                        Duration = 3
                    })
                    return
                end
            end
            Rayfield:Notify({Title="Unally Failed",Content="User not found",Duration=3})
        elseif args[1] == ";reset" or args[1] == ";respawn" then
            following = false
            spinning = false
            driving = false
            banging = false
            orbiting = false
            autoJump = false
            touring = false
            floating = false
            staring = false
            annoying = false
            helicopter = false
            guard = false
            guardSide = nil
            guardTarget = nil
            spinSpeed = 0
            driveSpeed = 0
            orbitAngle = 0
            orbitTarget = nil
            originalCFrame = nil
            bangTarget = nil
            stareTarget = nil
            annoyTarget = nil
            headstanding = false
            headstandTarget = nil
            inArmy = false
            armyIndex = nil
            armyTarget = nil
            copyChat = false
            copyChatTarget = nil
            npcMode = false
            if npcThread then
                npcThread:Disconnect()
                npcThread = nil
            end
            if character then
                character:BreakJoints()
            end
        elseif args[1] == ";ajump" or args[1] == ";autojump" then
            autoJump = true
        elseif args[1] == ";unajump" or args[1] == ";unautojump" then
            autoJump = false
        elseif args[1] == ";army" then
            inArmy = true
            armyIndex = (player.UserId % 10) + 1
            if args[2] then
                local userName = table.concat(args, " ", 2):lower()
                local found
                for _, plr in pairs(Players:GetPlayers()) do
                    if plr.Name:lower():find(userName) or plr.DisplayName:lower():find(userName) then
                        armyTarget = plr
                        found = true
                        break
                    end
                end
                if not found then
                    armyTarget = controllerPlayer
                end
            else
                armyTarget = controllerPlayer
            end
            local who = (armyTarget and armyTarget.DisplayName) or "the controller"
            Rayfield:Notify({
                Title="Army Mode",
                Content="Joined single-line army behind "..who.."!",
                Duration=3
            })
        elseif args[1] == ";unarmy" then
            inArmy = false
            armyIndex = nil
            armyTarget = nil
            Rayfield:Notify({
                Title="Army Mode",
                Content="Left the single-line army formation",
                Duration=3
            })
        elseif args[1] == ";copychat" and args[2] then
            local userName = table.concat(args, " ", 2):lower()
            local found = false
        
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(userName, 1, true) or p.DisplayName:lower():find(userName, 1, true) then
                    copyChat = true
                    copyChatTarget = p
                    Rayfield:Notify({
                        Title = "CopyChat",
                        Content = "Now copying " .. p.DisplayName .. "'s messages",
                        Duration = 3
                    })
                    found = true
                    break -- Stop loop after finding the player
                end
            end
        
            if not found then
                Rayfield:Notify({
                    Title = "CopyChat Failed",
                    Content = "User not found",
                    Duration = 3
                })
            end
        elseif args[1] == ";uncopychat" then
            copyChat = false
            copyChatTarget = nil
            Rayfield:Notify({
                Title = "CopyChat",
                Content = "Stopped copying chat",
                Duration = 3
            })
        elseif (args[1] == ";scare" or args[1] == ";spook") and args[2] then
            local targetName = args[2]:lower()
            for _, p in pairs(Players:GetPlayers()) do
                if p.Name:lower():find(targetName) or p.DisplayName:lower():find(targetName) then
                    local userRoot = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
                    if userRoot then
                        local oldCFrame = rootPart.CFrame
                        local direction = userRoot.CFrame.LookVector
                        local frontPos = userRoot.Position - (direction * 2)
                        rootPart.CFrame = CFrame.lookAt(frontPos, userRoot.Position)
                        wait(1)
                        if controllerPlayer and controllerPlayer.Character and controllerPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            rootPart.CFrame = controllerPlayer.Character.HumanoidRootPart.CFrame
                        else
                            rootPart.CFrame = oldCFrame
                        end
                    end
                    break
                end
            end
            local Players = game:GetService("Players")
            local localPlayer = Players.LocalPlayer
            local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local danceTrack = nil -- Store the animation track globally
            
            if humanoid then
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if not animator then
                    animator = Instance.new("Animator")
                    animator.Parent = humanoid
                end
            end
            
            elseif args[1]:lower() == ";dance" then
                if humanoid then
                    -- Load and play the dance animation
                    local danceAnimation = Instance.new("Animation")
                    danceAnimation.AnimationId = "rbxassetid://507771019" -- Replace with a valid dance animation ID
                    
                    danceTrack = humanoid.Animator:LoadAnimation(danceAnimation)
                    danceTrack.Looped = true
                    danceTrack:Play()
            
                    Rayfield:Notify({
                        Title = "Dance Mode",
                        Content = "Started dancing!",
                        Duration = 3
                    })
                end
            
            elseif args[1]:lower() == ";undance" then
                if danceTrack then
                    danceTrack:Stop()
                    danceTrack = nil
            
                    Rayfield:Notify({
                        Title = "Dance Mode",
                        Content = "Stopped dancing!",
                        Duration = 3
                    })
                end
            
        
        elseif args[1] == ";npc" then
            if not npcMode then
                npcMode = true
                Rayfield:Notify({
                    Title = "NPC Mode",
                    Content = "Bot is now moving randomly and chatting like an NPC",
                    Duration = 3
                })
        
                npcThread = task.spawn(function()
                    -- Send a message when NPC Mode starts
                    local message = npcPhrases[math.random(1, #npcPhrases)]
                    TextChatService.TextChannels.RBXGeneral:SendAsync(message)
        
                    while npcMode do
                        if rootPart and humanoid then
                            -- Move to a completely random position near the current location
                            local randomOffset = Vector3.new(
                                math.random(-npcSettings.moveDistance[1], npcSettings.moveDistance[2]), -- Random X movement range
                                0, 
                                math.random(-npcSettings.moveDistance[1], npcSettings.moveDistance[2])  -- Random Z movement range
                            )
                            local targetPosition = rootPart.Position + randomOffset
        
                            -- Move instantly without waiting too long
                            humanoid:MoveTo(targetPosition)
                            
                            -- Random chance to turn abruptly
                            if math.random() < 0.3 then
                                rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0)
                            end
                        end
                        
                        -- Wait between movements for a longer time
                        task.wait(math.random(npcSettings.moveWaitTime[1], npcSettings.moveWaitTime[2]))  -- Waits between 1 and 2 seconds
        
                        -- Random chance to say an NPC phrase every 6-10 seconds
                        if math.random() < 0.2 then  -- 20% chance to send message
                            local message = npcPhrases[math.random(1, #npcPhrases)]
                            TextChatService.TextChannels.RBXGeneral:SendAsync(message)
                        end
                    end
                end)
            end
        elseif args[1]:lower() == ";walkto" and args[2] then
            local userName = args[2]:lower()
            local targetPlayer = nil
    
            -- Find the player by name or display name
            for _, plr in pairs(Players:GetPlayers()) do
                if plr.Name:lower():find(userName) or plr.DisplayName:lower():find(userName) then
                    targetPlayer = plr
                    break
                end
            end
    
            if targetPlayer then
                walkingToTarget = true
                Rayfield:Notify({
                    Title = "Walking to Target",
                    Content = "Started walking to " .. targetPlayer.DisplayName,
                    Duration = 3
                })
    
                -- Continuously move towards the target
                task.spawn(function()
                    while walkingToTarget and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
                        local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
                        local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    
                        if humanoid and rootPart and targetRoot then
                            local direction = (targetRoot.Position - rootPart.Position).unit
                            humanoid:MoveTo(targetRoot.Position - direction * 2) -- Keeps a small distance
                        end
    
                        wait(0.1) -- Update movement every 0.1 seconds
                    end
                end)
    
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Target player not found.",
                    Duration = 3
                })
            end
    
        -- Command to stop walking
        elseif args[1]:lower() == ";unwalkto" then
            walkingToTarget = false
            Rayfield:Notify({
                Title = "Walking Stopped",
                Content = "Stopped walking to the target player.",
                Duration = 3
            })
    

        elseif args[1] == ";unnpc" then
            if npcMode then
                npcMode = false
        
                -- Stop the NPC thread if it's running
                if npcThread then
                    task.cancel(npcThread)
                    npcThread = nil
                end
        
                -- Stop NPC movement (set humanoid's movement to zero)
                if humanoid then
                    humanoid:Move(Vector3.new(0, 0, 0), true) -- Stops the bot from moving
                end
        
                Rayfield:Notify({
                    Title = "NPC Mode",
                    Content = "Stopped moving and chatting like an NPC",
                    Duration = 3
                })
            else
                Rayfield:Notify({
                    Title = "NPC Mode",
                    Content = "NPC Mode is already off.",
                    Duration = 3
                })
            end
        
            local originalCameraSubject = workspace.CurrentCamera.CameraSubject -- Store the original camera subject to reset later
            local originalCameraPosition = workspace.CurrentCamera.CFrame -- Store the original camera position
            
            elseif args[1]:lower() == ";view" or args[1]:lower() == ";spectate" then
                if args[2] then
                    local userName = args[2]:lower()
                    local foundPlayer = false
            
                    -- Find the player to spectate by username or display name
                    for _, player in pairs(Players:GetPlayers()) do
                        if player.Name:lower():find(userName, 1, true) or player.DisplayName:lower():find(userName, 1, true) then
                            foundPlayer = true
            
                            -- Notify that spectating has started
                            Rayfield:Notify({
                                Title = "Spectate Mode",
                                Content = "Now spectating " .. player.Name,
                                Duration = 3
                            })
            
                            -- Wait for the player's character to load
                            player.CharacterAdded:Connect(function(character)
                                -- Ensure the character is loaded
                                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
                                -- Set the camera to follow the player's humanoid root part
                                workspace.CurrentCamera.CameraSubject = humanoidRootPart
                                workspace.CurrentCamera.CameraType = Enum.CameraType.Attach
                            end)
            
                            -- Spectate the player's current character if it exists
                            if player.Character then
                                local character = player.Character
                                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                if humanoidRootPart then
                                    workspace.CurrentCamera.CameraSubject = humanoidRootPart
                                    workspace.CurrentCamera.CameraType = Enum.CameraType.Attach
                                end
                            end
            
                            break
                        end
                    end
            
                    -- If player not found
                    if not foundPlayer then
                        Rayfield:Notify({
                            Title = "Spectate Failed",
                            Content = "Player not found.",
                            Duration = 3
                        })
                    end
                else
                    Rayfield:Notify({
                        Title = "Spectate Failed",
                        Content = "No player specified to spectate.",
                        Duration = 3
                    })
                end


            elseif args[1]:lower() == ";sniff" and args[2] then
                local userName = args[2]:lower()
                local targetPlayer = nil
            
                -- Find the player by name or display name
                for _, plr in pairs(Players:GetPlayers()) do
                    if plr.Name:lower():find(userName) or plr.DisplayName:lower():find(userName) then
                        targetPlayer = plr
                        break
                    end
                end
            
                if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    sniffingTarget = true
                    local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
                    local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
            
                    if humanoid and rootPart then
                        humanoid.PlatformStand = true -- Make player lie down
            
                        -- Keep updating position
                        task.spawn(function()
                            while sniffingTarget and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
                                local targetRoot = targetPlayer.Character.HumanoidRootPart
                                
                                -- Match target's CFrame but stay on the floor
                                rootPart.CFrame = targetRoot.CFrame * CFrame.new(0, -2.5, -1) * CFrame.Angles(math.rad(90), 0, 0)
            
                                wait(0.1) -- Update position smoothly
                            end
                        end)
            
                        Rayfield:Notify({
                            Title = "Sniffing",
                            Content = "Sniffing " .. targetPlayer.DisplayName,
                            Duration = 3
                        })
                    end
                else
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Target player not found.",
                        Duration = 3
                    })
                end
            
            elseif args[1]:lower() == ";unsniff" then
                sniffingTarget = false
                local humanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = false -- Restore normal movement
                end
            
                Rayfield:Notify({
                    Title = "Sniffing Stopped",
                    Content = "Stopped sniffing the target.",
                    Duration = 3
                })
            
            
            
            
        
            elseif args[1]:lower() == ";unview" or args[1]:lower() == ";unspectate" then
                -- Reset the camera to the player's original character or the default subject
                if originalCameraSubject and originalCameraSubject.Parent then
                    -- Revert to the original camera subject (your own character)
                    workspace.CurrentCamera.CameraSubject = originalCameraSubject
                    workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
                else
                    -- If the original camera subject is invalid, reset the camera to the player's character
                    workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.HumanoidRootPart
                    workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
                end
            
                -- Reset the camera's position to where it was before spectating
                workspace.CurrentCamera.CFrame = originalCameraPosition
            
                Rayfield:Notify({
                    Title = "Spectate Mode",
                    Content = "Stopped spectating.",
                    Duration = 3
                })

        elseif args[1] == ";executor" or args[1] == ";exec" then
            if identifyexecutor then
                TextChatService.TextChannels.RBXGeneral:SendAsync("Executor: " .. identifyexecutor())
            else
                TextChatService.TextChannels.RBXGeneral:SendAsync("Executor: Unknown")
            end
            
        elseif args[1]:lower() == ";crash" or args[1]:lower() == ";shutdown" then
            Rayfield:Notify({
                Title = "Crash",
                Content = "You will be crashed in 3 seconds",
                Duration = 3
            })
            TextChatService.TextChannels.RBXGeneral:SendAsync("3")
            wait(1)
            TextChatService.TextChannels.RBXGeneral:SendAsync("2")
            wait(1)
            TextChatService.TextChannels.RBXGeneral:SendAsync("1, bye bye guys.")
            wait(1)
            while true do
                print("skibidi crash me ")
            end
        elseif args[1] == ";dadjoke" then
            local randomJoke = dadJokes[math.random(1, #dadJokes)]
            local success, errorMsg = pcall(function()
                TextChatService.TextChannels.RBXGeneral:SendAsync(randomJoke)
            end)
        
            if not success then
                Rayfield:Notify({
                    Title = "Dad Joke Warning",
                    Content = "This joke might be filtered by Roblox's chat system and may not be sent.",
                    Duration = 3
                })
            end
        end
    end   
end


for _, p in pairs(Players:GetPlayers()) do
    p.Chatted:Connect(function(msg)
        if not standbymode then
            onChatMessage(p, msg)
        else
            if not notified then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "The controller cannot run while stand is on!",
                    Duration = 2
                })
                notified = true
            end
        end
    end)
end

Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.Chatted:Connect(function(msg)
        if not standbymode then
            onChatMessage(newPlayer, msg)
        else
            if not notified then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "The controller cannot run while stand is on!",
                    Duration = 2
                })
                notified = true
            end
        end
    end)
end)

RunService.Heartbeat:Connect(function(dt)
    if following and followTarget then
        rootPart.CFrame = rootPart.CFrame:Lerp(CFrame.new(followTarget.Position) * CFrame.new(0, 0, 3), 0.1)
    end
    if spinning then
        local spinAmount = spinSpeed * 100 * dt
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(spinAmount), 0)
    end
    if orbiting and orbitTarget then
        orbitAngle = orbitAngle + math.rad(orbitSpeed * dt)
        local offset = Vector3.new(math.cos(orbitAngle) * orbitDistance, orbitHeight, math.sin(orbitAngle) * orbitDistance)
        
        -- Calculate new position
        local newPosition = orbitTarget.Position + offset
    
        -- Make the player face the target
        rootPart.CFrame = CFrame.lookAt(newPosition, orbitTarget.Position)
    end
    
    if autoJump and humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
    if driving then
        rootPart.CFrame = rootPart.CFrame * CFrame.new(0, 0, -driveSpeed * dt)
    end
    if banging and bangTarget then
        bangTime = bangTime + dt
        local oscillation = math.sin(bangTime * bangSpeed) * 2
        local desiredPos = bangTarget.Position - bangTarget.CFrame.LookVector * (4 + oscillation)
        rootPart.CFrame = CFrame.new(desiredPos)
    end
    if floating then
        local pos = rootPart.Position
        rootPart.CFrame = CFrame.new(pos.X, floatBaseY + floatHeight, pos.Z) -- Uses dynamic height
    end
    if staring and stareTarget then
        local direction = (stareTarget.Position - rootPart.Position)
        direction = Vector3.new(direction.X, 0, direction.Z).Unit
        rootPart.CFrame = CFrame.lookAt(rootPart.Position, rootPart.Position + direction)
    end
    if annoying and annoyTarget then
        local rx = math.random(-4,4)
        local rz = math.random(-4,4)
        rootPart.CFrame = CFrame.new(annoyTarget.Position + Vector3.new(rx, 0, rz))
    end
    if helicopter then
        helicopterTime = helicopterTime + dt
        local verticalOffset = math.sin(helicopterTime * 5) * 1.5
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(helicopterSpinSpeed * dt), 0)
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, verticalOffset, 0)
    end
    if guard and guardTarget then
        local offset = Vector3.new(2, 3, 0)
        if guardSide == "right" then
            offset = Vector3.new(-2, 3, 0)
        elseif guardSide == "left" then
            offset = Vector3.new(2, 3, 0)
        end
        local desiredCFrame = guardTarget.CFrame * CFrame.new(offset)
        rootPart.CFrame = rootPart.CFrame:Lerp(desiredCFrame, 0.2)
    end
    if headstanding and headstandTarget then
        local targetChar = headstandTarget.Character
        if targetChar and targetChar:FindFirstChild("HumanoidRootPart") then
            local targetRoot = targetChar.HumanoidRootPart
            rootPart.CFrame = CFrame.new(targetRoot.Position + Vector3.new(0, 3, 0))
        end
    end
    if inArmy and armyIndex and armyTarget and armyTarget.Character then
        local cRoot = armyTarget.Character:FindFirstChild("HumanoidRootPart")
        if cRoot then
            local offsetX = 4 * (armyIndex - 5.5)
            local offsetZ = 8
            rootPart.CFrame = cRoot.CFrame * CFrame.new(offsetX, 0, offsetZ)
        end
    end
end)
